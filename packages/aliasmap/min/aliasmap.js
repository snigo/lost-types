var AliasMap=function(){"use strict";class Entry{constructor(t,e,...s){this.key=t,this.value=e,this.aliases=new Set(s.filter(s=>s!==t||s!==e))}values(){return void 0!==this.key||void 0!==this.value||this.aliases.size?[this.key,this.value,...this.aliases]:[]}}const t=new WeakMap,e={strict:!0,immutable:!0},s=function(t){const e=Map.prototype.get.call(this,t);if(e)return t===e.key||t===e.value?this.delete(t):this.deleteAlias(e.key,t)},r=function(e){t.get(this).entryCount+=e},i=function(...t){if(t.some(t=>null==t)){if(!this.getOwnDescriptor().strict)return!1;throw TypeError("AliasMap entry cannot be null or undefined")}return!0},n=function(...t){if(this.getOwnDescriptor().immutable&&t.some(t=>this.has(t))){if(!this.getOwnDescriptor().strict)return!1;throw TypeError("Cannot reassign immutable entry. Delete entry first or set immutable property to false: .setOwnDescriptor({ immutable: false }).")}return!0},a=function(t,e,...s){if(s.some(s=>s===t||s===e)&&this.getOwnDescriptor().strict)throw TypeError("Key or value cannot be alias for itself")};class AliasMap extends Map{constructor(s=e){super();const r={entryCount:0,...e};Object.entries(s).forEach(([t,e])=>{r[t]=e}),t.set(this,r)}get entryCount(){return t.get(this).entryCount}get[Symbol.toStringTag](){return"AliasMap"}getOwnDescriptor(){const{strict:e,immutable:s}=t.get(this);return{strict:e,immutable:s}}getEntry(t){return super.get(t)}get(t){const e=this.getEntry(t);if(e)return e.value===t?e.key:e.value}getPrimaryKey(t){const e=this.getEntry(t);return e?e.key:e}getAliases(t){const e=this.getEntry(t);if(e&&"aliases"in e)return[...e.aliases]}getValue(t){const e=this.getEntry(t);return e?e.value:e}hasAlias(t,e){const s=this.getEntry(t);return!!s&&s.aliases.has(e)}delete(t){const e=this.getEntry(t);return!!e&&(super.delete(e.key),super.delete(e.value),e.aliases.forEach(t=>{super.delete(t)}),r.call(this,-1),!0)}deleteAlias(t,e){const s=this.getEntry(t);return!!s&&(s.aliases.has(e)&&super.delete(e)&&s.aliases.delete(e))}set(t,e,...l){if(!i.call(this,t,e,...l))return!1;const u=this.getEntry(t);if(u&&u.key===t&&u.value===e)return this.setAlias(t,...l);if(!n.call(this,t,e,...l))return!1;a.call(this,t,e,...l),u&&u.key===t&&(l=[...u.aliases,...l]);const o=new Entry(t,e,...l);return o.values().forEach(t=>{s.call(this,t),super.set(t,o)}),r.call(this,1),this}setAlias(t,...e){if(!i.call(this,...e))return!1;if(!n.call(this,...e))return!1;const r=this.getEntry(t);return!(!r||!e.length)&&(a.call(this,r.key,r.value,...e),e.forEach(t=>{r.aliases.has(t)||(s.call(this,t),r.aliases.add(t),super.set(t,r))}),[...r.aliases])}setOwnDescriptor(e){const s=this.getOwnDescriptor();"strict"in e&&"boolean"==typeof e.strict&&(s.strict=e.strict),"immutable"in e&&"boolean"==typeof e.immutable&&(s.immutable=e.immutable);const r={...t.get(this),...s};return t.set(this,r),s}clear(){return r.call(this,-this.entryCount),super.clear()}entries(){return[...new Set([...super.values()])]}keys(){return this.entries().map(t=>t.key)}values(){return this.entries().map(t=>t.value)}forEach(t,e){return this.entries().forEach(t,e)}}return AliasMap}();
